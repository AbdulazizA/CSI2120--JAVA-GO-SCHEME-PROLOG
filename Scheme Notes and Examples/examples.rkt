#lang scheme
; Always use the abvove lang declarations. 
(printf "-------(+ 3 4)--------\n")
(+ 3 4)
;7
(printf "-------Condtional Evaluvation--------\n")
( define (showIt pts)
    (cond ((or (<= pts 3) (>= pts 65) ) 0) 
            ((<= 4 pts 6) 0.5)  
            ((<= 10 pts 12) 1)
            (else 2.0))
)
(showIt 25)
(printf "-------LET--------\n")
(let ((a 3) (b 4))(* a b))
(printf "-------Cons-------\n")
(let ((a '(1 2 3)) (b '(4 5 6))) (cons a  b) )
(printf "-------Lambda-------\n")
((lambda (f x y)  (f x x) (f y y)  (f x y) (f y y)) + 2 3)
(printf "-------Factorial-------\n")
(define (fact n)
  ( if (> n 0)
    (* n (fact (- n 1))) 1
  )
)
(fact 35)
(printf "-------Fahrenheit to Celsius------\n")
(define (f-2-c temp)
  (/ (- temp 32) 1.8)
)
(f-2-c 32)
(printf "-------Lambda and Let------\n")
(let ((x 'a))
  (let ((f (lambda (y) (list x y))))
  (f 'b)  
  )
)
(printf "-------GCD------\n")
( define gcd 
    (lambda (a b) 
        (if (= a b) a
            (if (> a b) 
                (gcd (- a b) b) 
                (gcd a (- b a))
            )
        )
    )
)
(gcd 12 15)

(printf "-------eq?------\n")
(define hello "bonjour")
(eq? hello "bonjour")
(printf "-------eqv?------\n")
(eqv? '1 1)
(eqv? 2 (+ 1 1)) 
(eqv? 1 1.0)
(equal? (list 1 2) '(1 2))
(printf "-------Sequecne------\n")
(begin (display 'okay) (display 'great))
(begin (+ 1 9) (- 1 2))
(printf "-------CAR CDR CONS CDADR------\n")
(cons 'a '(b c))
(cons 'a'b)
(cdr '(a (b c)))
(cdr (car (cdr '(a (b c d) e))))
(cdadr '(a (b c d) e))
(cons (car '(a b c)) (cdr '(a b c)))
(printf "-------RECURSION Inverting------\n")
(define (append-list L1  L2)
  (if ( null? L1)
    L2
    (cons (car L1) (append-list (cdr L1) L2))
  )
)
(append-list '(a b) '(c d e f))
(printf "-------RECURSION Inverting list------\n")
(define (inverting L1) 
  ( if (null? L1)
    '()
    (append-list (inverting (cdr L1))
    (list (car L1)))))
(inverting '(a b c g f h))
(printf "-------RECURSION Find memebers from list------\n")
(define (memebers-list a L)
  (cond ((null? L)  '())
        ((equal? a (car L)) L)
        (#t (memebers-list a (cdr L)))
  )
)
(memebers-list 'c '(a b c d e))
(printf "-------RECURSION List length------\n")
(define (list-len L)
  (if (null? L) 0 (+ 1 (list-len (cdr L)))
  )
)
(list-len '(a b c d e))
(printf "-------RECURSION same neighbours------\n")
(define (sameNeig? L)
  (cond
      ((null? L) #f)
      ((null? (cdr L)) #f)
      ((equal? (car L) (car (cdr L))) #t)
      (else (sameNeig? (cdr L)))
  )
)
(sameNeig? '(1 2 3 3 5))
(printf "-------RECURSION number only list------\n")
(define (numOnly? L)
  (cond
      ((not (list? L)) #f)
      ((null? L) #t)
      ((not (number? (car L))) #f)
      (else (numOnly? (cdr L)))
  )
)
(numOnly? '(1 a 3 3 5))
(printf "-------RECURSION Cahr add-----\n")
(define (abc-count char k)
(if (char-alphabetic? char)
(let ((base (if (char-upper-case? char)
(char->integer #\A)
(char->integer #\a))))
(integer->char
(+ base
(modulo
(+ k
(- (char->integer char) base))
26))))
char)) ; apply let to char

(abc-count #\b 5)
(printf "-------ON of Set!-----\n")
(define light-switch (let ((lit #f)) (lambda ()
(set! lit (not lit))
(if lit 'on 'off)))) 
(light-switch)
(printf "-------DO -----\n")
(define fibonacci
(lambda (n)
(if (= n 0)
0
  (do 
  ((i n (- i 1)) (a1 1 (+ a1 a2)) (a2 0 a1)) 
  ((= i 1) a1)
  )
)))
(fibonacci 6)
(do ((i 0 (+ i 1)))
    ((= i 5) i)      ; maybe return the last value of the iteration
  (display i))
(printf "-------vector -----\n")

(define v (vector 2 (+ 1 2)))
v
(vector-ref v 0) ; index starts at 0

(vector-length v)

(vector-set! v 1 10)
(sort '(3 4 2 1 2 5) <) 